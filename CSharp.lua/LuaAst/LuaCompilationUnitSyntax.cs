/*
Copyright 2017 YANG Huan (sy.yanghuan@gmail.com).

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;

namespace CSharpLua.LuaAst {
  public sealed class GenericUsingDeclare : IComparable<GenericUsingDeclare> {
    public LuaInvocationExpressionSyntax InvocationExpression;
    public string NewName;
    public List<string> ArgumentTypeNames;
    public bool IsFromCode;

    public int CompareTo(GenericUsingDeclare other) {
      if (other.ArgumentTypeNames.Contains(NewName)) {
        return -1;
      }

      if (ArgumentTypeNames.Contains(other.NewName)) {
        return 1;
      }

      if (NewName.Length != other.NewName.Length) {
        return NewName.Length.CompareTo(other.NewName.Length);
      }

      return NewName.CompareTo(other.NewName);
    }

    public static void AddImportTo(
      List<GenericUsingDeclare> genericUsingDeclares,
      LuaInvocationExpressionSyntax invocationExpression, 
      string name, 
      List<string> argumentTypeNames, 
      bool isFromCode) {
      if (!genericUsingDeclares.Exists(i => i.NewName == name)) {
        genericUsingDeclares.Add(new GenericUsingDeclare() {
          InvocationExpression = invocationExpression,
          NewName = name,
          ArgumentTypeNames = argumentTypeNames,
          IsFromCode = isFromCode,
        });
      }
    }
  }

  public sealed class LuaCompilationUnitSyntax : LuaSyntaxNode {
    private sealed class UsingDeclare : IComparable<UsingDeclare> {
      public string Prefix;
      public string NewPrefix;
      public bool IsFromCode;

      public int CompareTo(UsingDeclare other) {
        return Prefix.CompareTo(other.Prefix);
      }
    }

    public string FilePath { get; }
    public readonly LuaSyntaxList<LuaStatementSyntax> Statements = new LuaSyntaxList<LuaStatementSyntax>();
    private LuaStatementListSyntax importAreaStatements = new LuaStatementListSyntax();
    private bool isImportLinq_;
    private int typeDeclarationCount_;
    private List<UsingDeclare> usingDeclares_ = new List<UsingDeclare>();
    private List<GenericUsingDeclare> genericUsingDeclares_ = new List<GenericUsingDeclare>();

    public LuaCompilationUnitSyntax(string filePath = "") {
      FilePath = filePath;
      var info = Assembly.GetExecutingAssembly().GetName();
      LuaShortCommentStatement versonStatement = new LuaShortCommentStatement($" Generated by {info.Name} Compiler");
      AddStatement(versonStatement);

      var system = LuaIdentifierNameSyntax.System;
      AddImport(system, system);
    }

    private static string GetVersion(Version version) {
      return $"{version.Major}.{version.Minor}.{version.Build}";
    }

    public void AddStatement(LuaStatementSyntax statement) {
      Statements.Add(statement);
    }

    public bool IsEmpty {
      get {
        return typeDeclarationCount_ == 0;
      }
    }

    public void ImportLinq() {
      if (!isImportLinq_) {
        AddImport(LuaIdentifierNameSyntax.Linq, LuaIdentifierNameSyntax.SystemLinqEnumerable);
        isImportLinq_ = true;
      }
    }

    private void AddImport(LuaIdentifierNameSyntax name, LuaExpressionSyntax value) {
      importAreaStatements.Statements.Add(new LuaLocalVariableDeclaratorSyntax(name, value));
    }

    internal void AddTypeDeclarationCount() {
      ++typeDeclarationCount_;
    }

    internal void AddImport(string prefix, string newPrefix, bool isFromCode) {
      if (!usingDeclares_.Exists(i => i.Prefix == prefix)) {
        usingDeclares_.Add(new UsingDeclare() {
          Prefix = prefix,
          NewPrefix = newPrefix,
          IsFromCode = true,
        });
      }
    }

    internal void AddImport(LuaInvocationExpressionSyntax invocationExpression, string name, List<string> argumentTypeNames, bool isFromCode) {
      GenericUsingDeclare.AddImportTo(genericUsingDeclares_, invocationExpression, name, argumentTypeNames, isFromCode);
    }

    private void CheckUsingDeclares() {
      var imports = usingDeclares_.Where(i => !i.IsFromCode).ToList();
      if (imports.Count > 0) {
        imports.Sort();
        foreach (var import in imports) {
          AddImport(import.NewPrefix, import.Prefix);
        }
      }

      var genericImports = genericUsingDeclares_.Where(i => !i.IsFromCode).ToList();

      var usingDeclares = usingDeclares_.Where(i => i.IsFromCode).ToList();
      var genericDeclares = genericUsingDeclares_.Where(i => i.IsFromCode).ToList();
      if (usingDeclares.Count > 0 || genericDeclares.Count > 0 || genericImports.Count > 0) {
        usingDeclares.Sort();
        genericDeclares.Sort();
        genericImports.Sort();

        foreach (var usingDeclare in usingDeclares) {
          AddImport(usingDeclare.NewPrefix, null);
        }

        foreach (var usingDeclare in genericDeclares) {
          AddImport(usingDeclare.NewName, null);
        }

        foreach (var import in genericImports) {
          AddImport(import.NewName, null);
        }

        var global = LuaIdentifierNameSyntax.Global;
        var functionExpression = new LuaFunctionExpressionSyntax();
        functionExpression.AddParameter(global);
        foreach (var usingDeclare in usingDeclares) {
          if (usingDeclare.Prefix != usingDeclare.NewPrefix) {
            var assignment = new LuaAssignmentExpressionSyntax(usingDeclare.NewPrefix, usingDeclare.Prefix);
            functionExpression.Body.Statements.Add(new LuaExpressionStatementSyntax(assignment));
          } else {
            var right = new LuaMemberAccessExpressionSyntax(global, usingDeclare.Prefix);
            var assignment = new LuaAssignmentExpressionSyntax(usingDeclare.NewPrefix, right);
            functionExpression.Body.Statements.Add(new LuaExpressionStatementSyntax(assignment));
          }
        }

        foreach (var usingDeclare in genericDeclares) {
          var assignment = new LuaAssignmentExpressionSyntax(usingDeclare.NewName, usingDeclare.InvocationExpression);
          functionExpression.Body.Statements.Add(new LuaExpressionStatementSyntax(assignment));
        }

        foreach(var genericImport in genericImports) {
          var assignment = new LuaAssignmentExpressionSyntax(genericImport.NewName, genericImport.InvocationExpression);
          functionExpression.Body.Statements.Add(new LuaExpressionStatementSyntax(assignment));
        }

        var invocationExpression = new LuaInvocationExpressionSyntax(LuaIdentifierNameSyntax.Import, functionExpression);
        importAreaStatements.Statements.Add(new LuaExpressionStatementSyntax(invocationExpression));
      }

      int index = Statements.FindIndex(i => i is LuaNamespaceDeclarationSyntax);
      if (index != -1) {
        Statements.Insert(index, importAreaStatements);
      }
    }

    internal override void Render(LuaRenderer renderer) {
      CheckUsingDeclares();
      renderer.Render(this);
    }
  }
}
